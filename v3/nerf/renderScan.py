from vedo import *
import open3d as o3d
import numpy as np
import trimesh
from ipyvtklink.viewer import ViewInteractiveWidget
import matplotlib.pyplot as pyplot


# Generate synthetic point cloud data
# points = np.random.rand(1000, 3).astype(np.float32)

#load point cloud generated by NeRF
# points = np.load('lidar_nerf_demo/generated_pc3.npy')
# points = np.load('generatedPointClouds/MaiCityNeRFOutput.npy')
points = np.load('generatedPointClouds/CombinedMaiCity.npy')

# pl = '/media/derm/06EF-127D4/Newer College Dataset/new-college-29-01-2020-1cm-resolution-1stSection - mesh.ply'
# points = trimesh.load(pl).vertices
# points[:,2] = -points[:,2] #flip z
# points = points[::10,:] #downsample

# Create an Open3D point cloud object
pcd = o3d.geometry.PointCloud()
pcd.points = o3d.utility.Vector3dVector(points)


# TEST Downsample point cloud
voxel_size = 0.1  # Adjust this value based on your data and desired level of downsampling
pcd = pcd.voxel_down_sample(voxel_size)

# Estimate normals for the point cloud
pcd.estimate_normals()


# Create a grey color array
num_points = np.asarray(pcd.points).shape[0]
# grey_color = np.tile([180/255, 180/255, 180/255], (num_points, 1))
# grey_color = np.tile([62/255, 142/255, 180/255], (num_points, 1))


# Assign the grey color to the point cloud
# pcd.colors = o3d.utility.Vector3dVector(grey_color)

#rainbow by z height
z_coordinates = np.asarray(pcd.points)[:, 2]
z_normalized = (z_coordinates - np.min(z_coordinates)) / (np.max(z_coordinates) - np.min(z_coordinates))
colormap = pyplot.get_cmap('rainbow')
colors = colormap(z_normalized)[:, :3]  # Get RGB values (discard the alpha channel)
pcd.colors = o3d.utility.Vector3dVector(colors)


# Visualize the point cloud
# o3d.visualization.draw_geometries([pcd])

#New~~~~~~~~~~~~~~~~~~~~~~~~~~~~

# Create a Visualizer object
vis = o3d.visualization.Visualizer()
vis.create_window()

# Add the point cloud to the visualizer
vis.add_geometry(pcd)

# Get the render option and set point size
render_option = vis.get_render_option()
render_option.point_size = 3.0 

# Run the visualizer
vis.run()
vis.destroy_window()

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

# # Downsample the point cloud
# pcd_downsampled = pcd.voxel_down_sample(voxel_size)

# # Generate dummy colors (white) for the downsampled point cloud
# num_points = np.asarray(pcd_downsampled.points).shape[0]
# dummy_colors = np.tile([1.0, 1.0, 1.0], (num_points, 1))  # White color
# pcd_downsampled.colors = o3d.utility.Vector3dVector(dummy_colors)

# # Create a volumetric representation (ScalableTSDFVolume)
# volume = o3d.pipelines.integration.ScalableTSDFVolume(
#     voxel_length=voxel_size,
#     sdf_trunc=voxel_size * 5,
#     color_type=o3d.pipelines.integration.TSDFVolumeColorType.NoColor,
#     volume_unit_resolution=16,
#     depth_sampling_stride=4
# )

# # Define intrinsic parameters
# intrinsic = o3d.camera.PinholeCameraIntrinsic()
# intrinsic.set_intrinsics(width=640, height=480, fx=500, fy=500, cx=320, cy=240)

# # Create a depth image and RGB image from the point cloud (dummy RGB image)
# # Assume a fixed depth image for demonstration; replace with actual data as needed
# depth_image = o3d.geometry.Image(np.ones((480, 640), dtype=np.float32))  # Dummy depth image
# rgb_image = o3d.geometry.Image((dummy_colors * 255).astype(np.uint8))  # Convert color to uint8

# # Create RGBDImage
# rgbd_image = o3d.geometry.RGBDImage.create_from_color_and_depth(rgb_image, depth_image, convert_rgb_to_intensity=False)

# # Integrate the RGBD image into the volume
# volume.integrate(rgbd_image, intrinsic, np.eye(4))

# # Extract a mesh using the marching cubes algorithm
# mesh = volume.extract_triangle_mesh()

# # Optionally, compute vertex normals for the mesh
# mesh.compute_vertex_normals()

# # Create a Visualizer object
# vis = o3d.visualization.Visualizer()
# vis.create_window()

# # Add the mesh to the visualizer
# vis.add_geometry(mesh)

# # Get the render option and set point size
# render_option = vis.get_render_option()
# render_option.point_size = 3.0 

# # Run the visualizer
# vis.run()
# vis.destroy_window()

#######

mesh, densities = o3d.geometry.TriangleMesh.create_from_point_cloud_poisson(pcd, depth=12) #9
# mesh, densities = o3d.geometry.TriangleMesh.create_from_point_cloud_ball_pivoting(pcd, depth=9)
vertices = np.asarray(mesh.vertices)
triangles = np.asarray(mesh.triangles)
faces = [list(triangle) for triangle in triangles]

# Create a vedo mesh
vedo_mesh = Mesh([vertices.tolist(), faces], c = [0.6,0.6,0.6])

disp = []
# disp.append(Points(points, c ='red'))
disp.append(vedo_mesh)

# Render the mesh using vedo
plt = Plotter(N = 1, axes = 4, bg = (1, 1, 1))
plt.show(disp, "Test Render", interactive=True)

########

#attempting to use PyMCubes package:

